\documentclass[12pt]{article}

%AMS-TeX packages

\usepackage{amssymb,amsmath,amsthm}
\usepackage{tikz-cd}
\usepackage{mathpartir}
% geometry (sets margin) and other useful packages
\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx,ctable,booktabs}

\usepackage[sort&compress,square,comma,authoryear]{natbib}
\bibliographystyle{plainnat}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}

\newcommand{\self}{\mathrm{self}}
\newcommand{\tm}{\mathrm{Tm}}
\newcommand{\pow}{\mathscr P}
\newcommand{\sem}[1]{\llbracket#1\rrbracket}
\newcommand{\semprod}[1]{\llbracket#1\rrbracket}
\newcommand{\semccc}[1]{\llparenthesis#1\rrparenthesis}
\newcommand{\sole}{\mathrm{sole}}
\newcommand{\var}{\mathrm{var}}
\newcommand{\app}{\mathrm{app}}
\newcommand{\Un}[1]{\mathrm{Un}_{#1}}

%
%Fancy-header package to modify header/page numbering
%
\usepackage{fancyhdr}
\pagestyle{fancy}
%\addtolength{\headwidth}{\marginparsep} %these change header-rule width
%\addtolength{\headwidth}{\marginparwidth}
\lhead{Section \thesection}
\chead{}
\rhead{\thepage}
\lfoot{\small\scshape EECS 598: Category Theory}
\cfoot{}
\rfoot{\footnotesize Scribed Notes}
\renewcommand{\headrulewidth}{.3pt}
\renewcommand{\footrulewidth}{.3pt}
\setlength\voffset{-0.25in}
\setlength\textheight{648pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Lecture 16: Canonicity II}
\author{Lecturer: Max S. New\\ Scribe: Alexander Bandukwala}
\date{October 22nd, 2025}
\maketitle

\section{Part 1 recap}
We continue our Logical Relations proof.

\[
\text{Given } \cdot \vdash M : 1 + 1, \quad
\text{we want to show that } M = \sigma_0() \text{ or } M = \sigma_1().
\]

So we need to strengthen our inductive hypothesis from Lecture 15. We need an inductive hypothesis that applies to every open term. So we define these sets of canonical terms.

\begin{align*}
C\ell(A) &:= \{ M \mid \cdot \vdash M : A \} \\
C\ell(\Gamma) &:= \{ \gamma \mid \gamma : \cdot \to \Gamma \} \\
\\
Can[A] &: C\ell(A) \to Set \\
Can[\Gamma] &: C\ell(\Gamma) \to Set \\
\\
Can[1](M) &:= \{ \star \} \\
Can[0](M) &:= \emptyset \\
Can[A \times B](M) &:= Can[A](\pi_1 M) \times Can[B](\pi_2 M) \\
Can[A_0+A_1](M) &:= (M = \sigma_0 N_0 \times Can[A_0](N_0)) \uplus (M = \sigma_1 N_1 \times Can[A_1](N_1)) \\
Can[A \to B](M) &:=  \prod_{N \in C\ell(A)} Can[A](N) \to Can[B](MN) \\
Can[\Gamma](\gamma) &:= \prod_{x :A \in \Gamma} Can[A](\gamma(x))
\end{align*}

\subsection{Fundamental Property/Lemma of the logical relation}
Define by recursion for all $\Gamma \vdash  M : A$ \\
\[
    Can[M]  :  \prod_{\gamma : C\ell(\Gamma)} Can[\Gamma](\gamma) \to Can[A](M[\gamma])
\]

\subsection{Partial canonicity proof:  case rule}
Consider
\[
\inferrule{
\Gamma \vdash M : A_0 + A_1 \\
\Gamma, x_0: A_0 \vdash P_0 : C \\
\Gamma, x_1: A_1 \vdash P_1 : C
}{\Gamma \vdash \text{case } \underline{M} \{\sigma_0 x_0 \to \underline{P_0} \mid \sigma_1 x_1 \to \underline{P_1}\} : C}
\]

Assume the inductive hypothesis for the underlined subterms. 

Given \(\gamma : C\ell(\Gamma)\) and \(\hat{\gamma} : Can[\Gamma](\gamma)\),
we must construct
\[
Can[C](\text{case } M \{\sigma_0 x_0 \to P_0 \mid \sigma_1 x_1 \to P_1\}[\gamma]).
\]

By the inductive hypothesis on \(M\),
\[
Can[M](\hat{\gamma}) : Can[A_0 + A_1](M[\gamma]).
\]
So \(Can[A_0 + A_1](M[\gamma])\) gives either
\[
(M[\gamma] = \sigma_0 N_0 \times \hat{N_0} : Can[A_0](N_0))
\quad\text{or}\quad
(M[\gamma] = \sigma_1 N_1 \times \hat{N_1} : Can[A_1](N_1)).
\]

In the first case, \(M[\gamma] = \sigma_0 N_0\).
By $\beta$-reduction,
\[
\text{case } M[\gamma] \{\sigma_0 x_0 \to P_0[\gamma] \mid \sigma_1 x_1 \to P_1[\gamma]\}
= P_0[\gamma, N_0 / x_0].
\]
We need a canonical proof of
\[
Can[\Gamma, x_0: A_0](\gamma, N_0/x_0).
\]
This is given by \(\hat{\gamma}\) together with \(\hat{N_0}\).
Then by the inductive hypothesis for \(P_0\),
\[
Can[C](P_0[\gamma, N_0/x_0]).
\]

The second case (\(M[\gamma] = \sigma_1 N_1\)) is symmetric.
\qed

\subsection{Lambda expressions}

\[
\inferrule{
  \Gamma, x: A \vdash M : B
}{
  \Gamma \vdash \lambda x.\, M : A \Rightarrow B
}
\]

Given \(\gamma : C\ell(\Gamma)\) and \(\hat{\gamma} : Can[\Gamma](\gamma)\), we must show
\[
Can[A \Rightarrow B]\big((\lambda x.\, M)[\gamma]\big).
\]

We have
\[
(\lambda x.\, M)[\gamma] = \lambda x.\, M[\gamma, x/x].
\]

By the definition of canonicity for function types, we are given
\[
N : C\ell(A)
\quad\text{and}\quad
\hat{N} : Can[A](N),
\]
and must construct
\[
Can[B]\big((\lambda x.\, M[\gamma, x/x])\, N\big).
\]

By $\beta$-reduction,
\[
(\lambda x.\, M[\gamma, x/x])\, N = M[\gamma, N/x].
\]

By the inductive hypothesis, we have a canonicality constructor for \(M\)
when applied to a canonical substitution:
\[
Can[M](\hat{\gamma}, \hat{N}/x),
\]
which gives the desired \(Can[B](M[\gamma, N/x])\).
\qed


\section{Using the Initiality Theorem to avoid induction}
Work in the category $\mathbf{SCwF}$ of simple categories with families.
\[
\text{STLC}[\emptyset]\longrightarrow LR,
\]
where \(LR\) is an SCwF that ``encodes'' the logical relation.

A practical way to build such a morphism is to construct \(LR\) \emph{over}
the syntactic model, i.e. equip \(LR\) with a projection
\(\pi_1:LR\to\text{STLC}[\emptyset]\) that preserves all SCwF structure:
every object (type/context) of \(LR\) lies over a corresponding syntactic
object, and constructors (products, sums, arrows, etc.) in \(LR\) project
to the corresponding syntactic constructors.  Concretely,
\[
\begin{tikzcd}[row sep=small]
LR \arrow[d] \\
\text{STLC}[\emptyset]
\end{tikzcd}
\]

The reason for this ``model-with-syntax'' approach is that the interpretation
of a type in \(LR\) refers to the type itself.

We know that for any ScWF that interprets all of the types that we get a homomomorphism, a functor of ScWF from the syntax into our model. And this is what we call the fundamental lemma

\[
\begin{tikzcd}[row sep=small]
|[alias=LRnode]| LR \\
|[alias=STLCnode]| \text{STLC}[\emptyset] \\
\arrow[d, "\pi_1", from=LRnode, to=STLCnode]
\arrow[u, bend right=60, swap, "FL", from=STLCnode, to=LRnode]
\end{tikzcd}
\]

We prove the initiality lemma by recursion. The initiality lemmas is packaging up that recursion in a reusable way. And the way that initiality comes into all this is that we know there's a unique functor of SCwF from $STLC[\emptyset]$ to anything else which means the $FL$ $\pi_1$ composition has to be equal to the identity. And this is going to encode the property that for every type we're defining a relation over it and for every term we're defining a canoninicity transformer about it.

\subsection{The logical-relation SCwF}

We define an SCwF \(LR\) that encodes the logical relation over the syntactic SCwF \(\text{STLC}[\emptyset]\).
\begin{align*}
LR_{ty} &:= (A : STLC_{ty}) \times (C\ell(A) \to \mathbf{Set}) \\
(LR_{c})_o &:= (\Gamma : STLC_{c,o}) \times (C\ell(\Gamma) \rightarrow \mathbf{Set}) \\
LR_{tm}(A, \hat{A})(\Gamma, \hat{\Gamma}) &:= (\Gamma \vdash M : A) \times (\prod_{\gamma: C\ell(\Gamma)} \hat{\Gamma}(\gamma) \rightarrow \hat{A}(M[\gamma]) \\ % Note \Gamma \vdash M : A is the same as M: STLC_tm A \Gamma
(LR_c)((\Delta, \hat{\Delta}), (\Gamma, \hat{\Gamma})) &:= (\gamma: \Delta \rightarrow \Gamma) \times (\prod_{x:A \in \Gamma}\prod_{\delta: C\ell(\Delta)}\hat{\Delta}(\delta) \rightarrow \hat{A}(\gamma(x)[\delta])) \\
(M, \hat{M}) \circ (\gamma, \hat{\gamma}) &:= (M[\gamma], \lambda \delta: C\ell(\Delta). \lambda\hat{\delta}: \hat{\Delta}. \hat{M}(\hat{\gamma}(\hat{\delta}))\hat{A}(M[\gamma][\delta]))
\end{align*}

Here we use the notation \(\hat{A} := C\ell(A) \to \mathbf{Set}\) and \(\hat{\Gamma} := C\ell(\Gamma) \to \mathbf{Set}\).

\subsection{Closed Terms and Families}

We have a functor from the syntactic category of STLC contexts to \(\mathbf{Set}\) that takes each context to its set of *closed terms*:

\[
\text{STLC}[\emptyset] \xrightarrow[]{C\ell} \mathbf{Set}.
\]

More generally, for any simple category with families \(S\), we can define a similar construction of *closed terms*. The idea is that \(C\ell\) maps each type \(A\) in \(S\) to the set of its closed terms, and each context \(\Gamma\) to the set of closed substitutions into it:
\[
C\ell(A) := Tm^S_{\emptyset}(A)
\qquad\text{and}\qquad
C\ell(\Gamma) := S(\emptyset, \Gamma).
\]
Thus, we can view \(C\ell\) as a functor
\[
S[\emptyset] \xrightarrow[]{C\ell} \mathbf{Set}.
\]

The other component we need is the which is another simple category with families, called \(\mathbf{Fam}\) (for “families”). In this category:
\[
\mathbf{Fam} = \{(A : \mathbf{Set},\, A \to \mathbf{Set})\},
\]
so each object is a set equipped with a family of sets indexed by it.

Putting these pieces together, we can view the logical relation construction \(LR\) that combines the syntax and semantics:
\[
\begin{tikzcd}
    LR \arrow[r] \arrow[d] & \mathbf{Fam} \arrow[d, "\pi_1"] \\
    \text{STLC}^{C(\emptyset)} \arrow[r, "C\ell"] & \mathbf{Set}
\end{tikzcd}
\]

\end{document}
